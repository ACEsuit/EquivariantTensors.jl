using Test, EquivariantTensors, StaticArrays, SpheriCart, Combinatorics
using EquivariantTensors.O3: Ctran, coupling_coeffs, gram
using PartialWaveFunctions: clebschgordan
using LinearAlgebra, Random
using WignerD, Rotations, BlockDiagonals

isdefined(Main, :___UTILS_FOR_TESTS___) || include("utils/utils_testO3.jl")

# The full test set is quite large and takes a while, for a quick sanity test 
# it is better to keep the test small so it runs quickly. 
#
___O3_TESTS___ = :small 
# :___O3_TESTS___ = :large


##

if ___O3_TESTS___ == :small
   @info("Using SMALL couplings test set")
   Lmax = 2
   lmax = 4 
   nmax = 4 
   ORDmax = 3 
elseif ___O3_TESTS___ == :large
   @info("Using LARGE couplings test set")
   Lmax = 4
   lmax = 4 
   nmax = 4 
   ORDmax = 5 
end


@info("Equivariance and Linear Independence of coupled cSH & rSH based basis")

for L = 0:Lmax 
   global Lmax, lmax, nmax, ORDmax
   local θ, ll, Ure, Ure_r, U_rpe, U_rpe_r, Mll, Mll_r 
   local X, Q, B1, B2, B3, B4, B5, B6, B7, B8
   local rk, rk_r, ntest
   local BB, BB_r, BB_sym, BB_sym_r

   # generate an nnll list for each L for testing
   nnll_list = [] 

   for ORD = 2:ORDmax
      for ll in with_replacement_combinations(1:lmax, ORD) 
         # 0 or 1 above ?
         if !iseven(sum(ll)+L); continue; end  # This is to ensure the reflection symmetry
         if sum(ll) > 2 * lmax; continue; end 
         for Inn in CartesianIndices( ntuple(_->1:nmax, ORD) )
            nn = [ Inn.I[α] for α = 1:ORD ]
            if sum(nn) > sum(1:nmax); continue; end
            nnll = [ (ll[α], nn[α]) for α = 1:ORD ]
            if !issorted(nnll); continue; end
            push!(nnll_list, (SVector(nn...), SVector(ll...)))
         end
      end
   end

   long_nnll_list = nnll_list 
   short_nnll_list = nnll_list[1:10:end]
   ultra_short_nnll_list = nnll_list[1:100:end]

   verbose = true 

   @info("Using ultra short nnll list for testing the case L = $L")
   nnll_list = ultra_short_nnll_list

   for (itest, (nn, ll)) in enumerate(nnll_list)
      local N 
      nn = shuffle(nn)
      ll = shuffle(ll)
      # @show nn, ll
      N = length(ll)
      @assert length(ll) == length(nn)

      Ure, Mll = coupling_coeffs(L, ll, nn; PI = false) # cSH based re_basis
      Ure_r, Mll_r = coupling_coeffs(L, ll, nn; PI = false, basis = real) # rSH based re_basis
      Urpe, Mll_rpe = coupling_coeffs(L, ll, nn) # cSH based rpe_basis
      Urpe_r, Mll_r_rpe = coupling_coeffs(L, ll, nn; basis = real) # rSH based rpe_basis

      rk = rank(gram(Ure), rtol = 1e-12)
      rk_r = rank(gram(Ure_r), rtol = 1e-12)
      rk_rpe = rank(gram(Urpe), rtol = 1e-12)
      rk_r_rpe = rank(gram(Urpe_r), rtol = 1e-12)
      
      # Check that the two rpe bases, generated by rSH and cSH, have the same 
      # dimensionality
      print_tf(@test rk == rk_r)
      # NOTE: re_basis and rpe_basis share the same Mll / Mll_r

      # This would mean that both the bases are empty; 
      if norm(Ure) == norm(Ure_r) == 0 ; continue; end 
      # Check that the Ure and Ure_r basis span the spaces that have the 
      # same dimension, and the dimensionality is the same as the size of Ure 
      # and Ure_r (full rank)
      print_tf(@test ( size(Ure, 1) == size(Ure_r, 1) 
                       == rank(gram(Ure), rtol = 1e-12) 
                       == rank(gram(Ure_r), rtol = 1e-12) ) )

      X = [ (0.1 + 0.9 * rand()) * rand_sphere() for i in 1:length(ll) ]
      θ = rand(3) * 2pi
      Q = RotZYZ(θ...)
      B1 = eval_basis(X; coeffs=Ure, MM=Mll, ll=ll, nn=nn, Real = false)
      B2 = eval_basis(Ref(Q) .* X; coeffs=Ure, MM=Mll, ll=ll, nn=nn, Real = false)
      B3 = eval_basis(X; coeffs=Ure_r, MM=Mll_r, ll=ll, nn=nn, Real = true)
      B4 = eval_basis(Ref(Q) .* X; coeffs=Ure_r, MM=Mll_r, ll=ll, nn=nn, Real = true)
      B5 = eval_sym_basis(X; coeffs=Urpe, MM=Mll_rpe, ll=ll, nn=nn, Real = false)
      B6 = eval_sym_basis(Ref(Q) .* X; coeffs=Urpe, MM=Mll_rpe, ll=ll, nn=nn, Real = false)
      B7 = eval_sym_basis(X; coeffs=Urpe_r, MM=Mll_r_rpe, ll=ll, nn=nn, Real = true)
      B8 = eval_sym_basis(Ref(Q) .* X; coeffs=Urpe_r, MM=Mll_r_rpe, ll=ll, nn=nn, Real = true)

      # Check the equivariance of the basis
      # TODO: combine into a single test 
      if L == 0
         print_tf(@test norm(B1 - B2) < 1e-12)
         print_tf(@test norm(B3 - B4) < 1e-12)
         print_tf(@test norm(B5 - B6) < 1e-12)
         print_tf(@test norm(B7 - B8) < 1e-12)
      else
         D = transpose(WignerD.wignerD(L, θ...))
         D_r = Ctran(L) * D * Ctran(L)'
         print_tf(@test norm(B1 - Ref(D) .* B2)   < 1e-12)
         print_tf(@test norm(B3 - Ref(D_r) .* B4) < 1e-12)
         print_tf(@test norm(B5 - Ref(D) .* B6)   < 1e-12)
         print_tf(@test norm(B7 - Ref(D_r) .* B8) < 1e-12)
      end

      # @info("Check the linear independence of the basis")
      ntest = 1000

      Xs = make_batch(ntest, length(ll))
      BB = rand_batch(; coeffs=Ure, MM=Mll, ll=ll, nn=nn, batch = Xs, Real = false)
      print_tf(@test rank(gram(BB); rtol=1e-12) == size(BB,1) == rk)
      BB_r = rand_batch(; coeffs=Ure_r, MM=Mll_r, ll=ll, nn=nn, batch = Xs, Real = true)
      print_tf(@test rank(gram(BB_r); rtol=1e-12) == size(BB_r,1) == rk_r)

      BB_sym = sym_rand_batch(; coeffs=Urpe, MM=Mll_rpe, ll=ll, nn=nn, batch = Xs, Real = false)
      print_tf(@test rank(gram(BB_sym); rtol=1e-12) == size(BB_sym,1) == rk_rpe)
      BB_sym_r = sym_rand_batch(; coeffs=Urpe_r, MM=Mll_r_rpe, ll=ll, nn=nn, batch = Xs, Real = true)
      print_tf(@test rank(gram(BB_sym_r); rtol=1e-12) == size(BB_sym_r,1) == rk_r_rpe)

   end
   println()

   @info("Using short ll list for testing the case L = $L with the absence of nn")
   ll_list = [ nnll_list[i][2] for i in 1:length(nnll_list) ] |> unique
   for (itest, ll) in enumerate(ll_list)
      local N 
      N = length(ll)

      Ure, Mll = coupling_coeffs(L, ll; PI = false) # cSH based re_basis
      Ure_r, Mll_r = coupling_coeffs(L, ll; PI = false, basis = :SpheriCart) # rSH based re_basis
      Urpe, Mll = coupling_coeffs(L, ll) # cSH based rpe_basis
      Urpe_r, Mll_r = coupling_coeffs(L, ll; basis = :SpheriCart) # rSH based rpe_basis

      rk = rank(gram(Urpe), rtol = 1e-12)
      rk_r = rank(gram(Urpe_r), rtol = 1e-12)
      
      # Check that the two rpe bases, generated by rSH and cSH, have the same 
      # dimensionality
      print_tf(@test rk == rk_r)
      # NOTE: re_basis and rpe_basis share the same Mll / Mll_r

      # This would mean that both the bases are empty; 
      if norm(Ure) == norm(Ure_r) == 0 ; continue; end 
      # Check that the Ure and Ure_r basis span the spaces that have the 
      # same dimension, and the dimensionality is the same as the size of Ure 
      # and Ure_r (full rank)
      print_tf(@test ( size(Ure, 1) == size(Ure_r, 1) 
                       == rank(gram(Ure), rtol = 1e-12) 
                       == rank(gram(Ure_r), rtol = 1e-12) ) )

      X = [ (0.1 + 0.9 * rand()) * rand_sphere() for i in 1:length(ll) ]
      θ = rand(3) * 2pi
      Q = RotZYZ(θ...)
      B1 = eval_basis(ll, Ure, Mll, X; Real = false)
      B2 = eval_basis(ll, Ure, Mll, Ref(Q) .* X; Real = false)
      B3 = eval_basis(ll, Ure_r, Mll_r, X; Real = true)
      B4 = eval_basis(ll, Ure_r, Mll_r, Ref(Q) .* X; Real = true)
      B5 = eval_basis(ll, Urpe, Mll, X; Real = false)
      B6 = eval_basis(ll, Urpe, Mll, Ref(Q) .* X; Real = false)
      B7 = eval_basis(ll, Urpe_r, Mll_r, X; Real = true)
      B8 = eval_basis(ll, Urpe_r, Mll_r, Ref(Q) .* X; Real = true)

      # Check the equivariance of the basis
      # TODO: combine into a single test 
      if L == 0
         print_tf(@test norm(B1 - B2) < 1e-12)
         print_tf(@test norm(B3 - B4) < 1e-12)
         print_tf(@test norm(B5 - B6) < 1e-12)
         print_tf(@test norm(B7 - B8) < 1e-12)
      else
         D = transpose(WignerD.wignerD(L, θ...))
         D_r = Ctran(L) * D * Ctran(L)'
         print_tf(@test norm(B1 - Ref(D) .* B2)   < 1e-12)
         print_tf(@test norm(B3 - Ref(D_r) .* B4) < 1e-12)
         print_tf(@test norm(B5 - Ref(D) .* B6)   < 1e-12)
         print_tf(@test norm(B7 - Ref(D_r) .* B8) < 1e-12)
      end

      # @info("Check the linear independence of the basis")
      nn = SVector{N, Int}((1:N)...)
      # With the absence of nn, nn are set to be SVector{N, Int}((1:N)...) by default
      ntest = 1000

      Xs = make_batch(ntest, length(ll))
      BB = rand_batch(; coeffs=Urpe, MM=Mll, ll=ll, nn=nn, batch = Xs, Real = false)
      print_tf(@test rank(gram(BB); rtol=1e-12) == size(BB,1) == rk)
      BB_r = rand_batch(; coeffs=Urpe_r, MM=Mll_r, ll=ll, nn=nn, batch = Xs, Real = true)
      print_tf(@test rank(gram(BB_r); rtol=1e-12) == size(BB_r,1) == rk_r)

      BB_sym = sym_rand_batch(; coeffs=Urpe, MM=Mll, ll=ll, nn=nn, batch = Xs, Real = false)
      print_tf(@test rank(gram(BB_sym); rtol=1e-12) == size(BB_sym,1) == rk)
      BB_sym_r = sym_rand_batch(; coeffs=Urpe_r, MM=Mll_r, ll=ll, nn=nn, batch = Xs, Real = true)
      print_tf(@test rank(gram(BB_sym_r); rtol=1e-12) == size(BB_sym_r,1) == rk_r)

   end
   println()
end
