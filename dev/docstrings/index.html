<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings ¬∑ EquivariantTensors.jl</title><meta name="title" content="Docstrings ¬∑ EquivariantTensors.jl"/><meta property="og:title" content="Docstrings ¬∑ EquivariantTensors.jl"/><meta property="twitter:title" content="Docstrings ¬∑ EquivariantTensors.jl"/><meta name="description" content="Documentation for EquivariantTensors.jl."/><meta property="og:description" content="Documentation for EquivariantTensors.jl."/><meta property="twitter:description" content="Documentation for EquivariantTensors.jl."/><meta property="og:url" content="https://ACEsuit.github.io/EquivariantTensors.jl/docstrings/"/><meta property="twitter:url" content="https://ACEsuit.github.io/EquivariantTensors.jl/docstrings/"/><link rel="canonical" href="https://ACEsuit.github.io/EquivariantTensors.jl/docstrings/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">EquivariantTensors.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../api/">Public API</a></li><li class="is-active"><a class="tocitem" href>Docstrings</a></li><li><a class="tocitem" href="../benchmarking/">Benchmarking</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Docstrings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Docstrings</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ACEsuit/EquivariantTensors.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/main/docs/src/docstrings.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Docstrings"><a class="docs-heading-anchor" href="#Docstrings">Docstrings</a><a id="Docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#Docstrings" title="Permalink"></a></h1><p>This page lists <em>all</em> docstrings in <code>EquivariantTensors.jl</code> including for functions that are not part of the public API. Please check with the <a href="../api/#Public-API">Public API</a> for which functionality we aim to guarantee semver-stability.</p><ul><li><a href="#EquivariantTensors.EdgeEmbed"><code>EquivariantTensors.EdgeEmbed</code></a></li><li><a href="#EquivariantTensors.EmbedDP"><code>EquivariantTensors.EmbedDP</code></a></li><li><a href="#EquivariantTensors.NTtransformST"><code>EquivariantTensors.NTtransformST</code></a></li><li><a href="#EquivariantTensors.O3.TYVec2CartMat"><code>EquivariantTensors.O3.TYVec2CartMat</code></a></li><li><a href="#EquivariantTensors.O3.TYVec2CartVec"><code>EquivariantTensors.O3.TYVec2CartVec</code></a></li><li><a href="#EquivariantTensors.O3.TYVec2YMat"><code>EquivariantTensors.O3.TYVec2YMat</code></a></li><li><a href="#EquivariantTensors.PooledSparseProduct"><code>EquivariantTensors.PooledSparseProduct</code></a></li><li><a href="#EquivariantTensors.SelectLinL"><code>EquivariantTensors.SelectLinL</code></a></li><li><a href="#EquivariantTensors.SparseMatCSX"><code>EquivariantTensors.SparseMatCSX</code></a></li><li><a href="#EquivariantTensors.SparseSymmProd"><code>EquivariantTensors.SparseSymmProd</code></a></li><li><a href="#EquivariantTensors.O3.D_from_angles-Tuple{Integer, AbstractVector{&lt;:Real}, typeof(real)}"><code>EquivariantTensors.O3.D_from_angles</code></a></li><li><a href="#EquivariantTensors.O3.QD_from_angles-Tuple{Integer, AbstractVector{&lt;:Real}, Any}"><code>EquivariantTensors.O3.QD_from_angles</code></a></li><li><a href="#EquivariantTensors.O3.coupling_coeffs"><code>EquivariantTensors.O3.coupling_coeffs</code></a></li><li><a href="#EquivariantTensors._auto_Rnl_spec-Tuple{Any}"><code>EquivariantTensors._auto_Rnl_spec</code></a></li><li><a href="#EquivariantTensors._auto_Ylm_spec-Tuple{Any, Any}"><code>EquivariantTensors._auto_Ylm_spec</code></a></li><li><a href="#EquivariantTensors._auto_nnllmm_spec-Tuple{Any}"><code>EquivariantTensors._auto_nnllmm_spec</code></a></li><li><a href="#EquivariantTensors._make_idx_AA_spec-Tuple{Any, Any}"><code>EquivariantTensors._make_idx_AA_spec</code></a></li><li><a href="#EquivariantTensors._make_idx_A_spec-Tuple{Any, Vector{@NamedTuple{n::Int64}}, Any}"><code>EquivariantTensors._make_idx_A_spec</code></a></li><li><a href="#EquivariantTensors.agnesi_params-Tuple{Integer, Integer, Real, Real, Real}"><code>EquivariantTensors.agnesi_params</code></a></li><li><a href="#EquivariantTensors.agnesi_transform-Tuple{Any, Any, Any, Any, Integer, Integer}"><code>EquivariantTensors.agnesi_transform</code></a></li><li><a href="#EquivariantTensors.cat2idx-Tuple{Any, Any}"><code>EquivariantTensors.cat2idx</code></a></li><li><a href="#EquivariantTensors.catcat2idx-NTuple{4, Any}"><code>EquivariantTensors.catcat2idx</code></a></li><li><a href="#EquivariantTensors.catcat2idx_sym-Tuple{Any, Any, Any}"><code>EquivariantTensors.catcat2idx_sym</code></a></li><li><a href="#EquivariantTensors.dp_transform-Tuple{Function}"><code>EquivariantTensors.dp_transform</code></a></li><li><a href="#EquivariantTensors.eval_agnesi-Tuple{Real, NamedTuple}"><code>EquivariantTensors.eval_agnesi</code></a></li><li><a href="#EquivariantTensors.invmap"><code>EquivariantTensors.invmap</code></a></li><li><a href="#EquivariantTensors.reshape_embedding-Tuple{Any, EquivariantTensors.ETGraph}"><code>EquivariantTensors.reshape_embedding</code></a></li><li><a href="#EquivariantTensors.rev_reshape_embedding-Tuple{Any, EquivariantTensors.ETGraph}"><code>EquivariantTensors.rev_reshape_embedding</code></a></li><li><a href="#EquivariantTensors.setproduct-Tuple{Any}"><code>EquivariantTensors.setproduct</code></a></li><li><a href="#EquivariantTensors.sparse_equivariant_tensor-Tuple{}"><code>EquivariantTensors.sparse_equivariant_tensor</code></a></li><li><a href="#EquivariantTensors.sparse_product-Tuple{}"><code>EquivariantTensors.sparse_product</code></a></li><li><a href="#EquivariantTensors.symidx-Tuple{Any, Any, Any}"><code>EquivariantTensors.symidx</code></a></li><li><a href="#EquivariantTensors.symmetrisation_matrix-Tuple{Integer, Any}"><code>EquivariantTensors.symmetrisation_matrix</code></a></li></ul><article><details class="docstring" open="true"><summary id="EquivariantTensors.EdgeEmbed"><a class="docstring-binding" href="#EquivariantTensors.EdgeEmbed"><code>EquivariantTensors.EdgeEmbed</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>struct EdgeEmbed </p><p>Wraps a layer that embeds an edge state into Vector to manage the  reformatting of the embedding from a list of embedded states into  a 3-dimensionsonal tensor that is aware of the graph structure.</p><p>Also implements an evaluate_ed wrapper, which is useful for  computing jacobians. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/embed/embeddings.jl#L14-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.EmbedDP"><a class="docstring-binding" href="#EquivariantTensors.EmbedDP"><code>EquivariantTensors.EmbedDP</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>struct EmbedDP </p><p>Embed a particle state into a vector. This is done by first applying a  transform to the particle state into a number of SVector and then evaluating  the basis (or other layer) on the transformed state. </p><p>This is basically a 3-stage Chain, but with additional logic, specifically  the implementation of evaluate_ed allowing differentiation through  and XState or NamedTuple input. This is e.g. needed for jacobians. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/embed/embeddings.jl#L55-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.NTtransformST"><a class="docstring-binding" href="#EquivariantTensors.NTtransformST"><code>EquivariantTensors.NTtransformST</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>Implementation of <code>nt_transform</code> and <code>dp_transform</code>. For details  see the docstring for those. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/transforms/decpart.jl#L57-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.PooledSparseProduct"><a class="docstring-binding" href="#EquivariantTensors.PooledSparseProduct"><code>EquivariantTensors.PooledSparseProduct</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p><code>struct PooledSparseProduct</code> :  This implements a fused (tensor) product and pooling operation. Suppose  we are given <span>$N$</span> embeddings <span>$\phi^{(i)}_{k_i}$</span> then the pooled sparse product  generates feature vectors of the form </p><p class="math-container">\[A_{k_1, \dots, k_N} = \sum_{j} \prod_{t = 1}^N \phi^{(t)}_{k_t}(x_j)\]</p><p>where <span>$x_j$</span> are an list of inputs (multi-set). </p><p>The canonical example is </p><p class="math-container">\[A_{nlm} = \sum_{j} R_{nl}(r_j, \mu_j) Y_l^m( \hat{\bm r}_j ),\]</p><p>where <span>$R_{nl}$</span> is a radial embedding, possibly depending on a categorical  variable <span>$\mu_j$</span> and <span>$Y_l^m$</span> are spherical harmonics. </p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">PooledSparseProduct(spec)</code></pre><p>where <code>spec</code> is a list of <span>$(k_1, \dots, k_N)$</span> tuples or vectors, or  <code>AbstractMatrix</code> where each column specifies such a tuple. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/ace/sparseprodpool.jl#L7-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.SelectLinL"><a class="docstring-binding" href="#EquivariantTensors.SelectLinL"><code>EquivariantTensors.SelectLinL</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>struct SelectLinL &lt;: AbstractLuxLayer</p><p>A Lux layer which acts as a simple linear layer, but using a categorical  variable to select a weight matrix:</p><pre><code class="language-julia hljs">   P -&gt; W[x] * P </code></pre><p>This layer is experimental and likely very inefficient. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/utils/selectlinl.jl#L3-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.SparseMatCSX"><a class="docstring-binding" href="#EquivariantTensors.SparseMatCSX"><code>EquivariantTensors.SparseMatCSX</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>struct SparseMatCSX</p><p>Sparse matrix format that is stored in both CSR and CSC, and can be transferred  to GPU devices. Matrix multiplication via KernelAbstractions.jl for GPU support and uses whichever format (CSR, CSC) is most suitable for a given operation. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/ace/sparsemat_ka.jl#L9-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.SparseSymmProd"><a class="docstring-binding" href="#EquivariantTensors.SparseSymmProd"><code>EquivariantTensors.SparseSymmProd</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p><code>SparseSymmProd</code> : sparse symmetric product with entries stored as tuples.  Input is a vector <code>A</code>; each entry of the output vector <code>AA</code> is of the form </p><p class="math-container">\[ {\bm A}_{i_1, \dots, i_N} = \prod_{t = 1}^N A_{i_t}.\]</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">SparseSymmProd(spec)</code></pre><p>where <code>spec</code> is a list of tuples or vectors, each of which specifies an <code>AA</code> basis function as described above. For example, </p><pre><code class="language-julia hljs">spec = [ (1,), (2,), (1,1), (1,2), (2,2), 
         (1,1,1), (1,1,2), (1,2,2), (2,2,2) ]
basis = SparseSymmProd(spec)         </code></pre><p>defines a basis of 9 functions, </p><p class="math-container">\[[ A_1, A_2, A_1^2, A_1 A_2, A_2^2, A_1^3, A_1^2 A_2, A_1 A_2^2, A_2^3 ]\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/ace/sparsesymmprod.jl#L4-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors._auto_Rnl_spec-Tuple{Any}"><a class="docstring-binding" href="#EquivariantTensors._auto_Rnl_spec-Tuple{Any}"><code>EquivariantTensors._auto_Rnl_spec</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Takes a list of ùî∏ or ùîπ specifications (many-body) in the form of </p><pre><code class="language-julia hljs">   [  [(n=., l=., m=.), (n=., l=., m=.)], ... ]</code></pre><p>and converts it into a list of sorted unique <code>(n=., l=.)</code> named pairs,  i.e the specification of the one-body basis. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/ace/sparse_ace_utils.jl#L106-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors._auto_Ylm_spec-Tuple{Any, Any}"><a class="docstring-binding" href="#EquivariantTensors._auto_Ylm_spec-Tuple{Any, Any}"><code>EquivariantTensors._auto_Ylm_spec</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p><em>auto</em>Ylm<em>spec(mb</em>spec) </p><p>takes a list of ùî∏ or ùîπ specifications (many-body) and return the specification  of the Ylm basis functions as a [ (l = ., m = .), ... ] list. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/ace/sparse_ace_utils.jl#L123-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors._auto_nnllmm_spec-Tuple{Any}"><a class="docstring-binding" href="#EquivariantTensors._auto_nnllmm_spec-Tuple{Any}"><code>EquivariantTensors._auto_nnllmm_spec</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>takes an nnll spec and generates a complete list of all possible nnllmm</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/ace/sparse_ace_utils.jl#L146-L148">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors._make_idx_AA_spec-Tuple{Any, Any}"><a class="docstring-binding" href="#EquivariantTensors._make_idx_AA_spec-Tuple{Any, Any}"><code>EquivariantTensors._make_idx_AA_spec</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>convert readable AA_spec into the internal representation of the AA basis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/ace/sparse_ace_utils.jl#L195-L197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors._make_idx_A_spec-Tuple{Any, Vector{@NamedTuple{n::Int64}}, Any}"><a class="docstring-binding" href="#EquivariantTensors._make_idx_A_spec-Tuple{Any, Vector{@NamedTuple{n::Int64}}, Any}"><code>EquivariantTensors._make_idx_A_spec</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>convert readable A_spec into the internal representation of the A basis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/ace/sparse_ace_utils.jl#L171-L173">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.agnesi_params-Tuple{Integer, Integer, Real, Real, Real}"><a class="docstring-binding" href="#EquivariantTensors.agnesi_params-Tuple{Integer, Integer, Real, Real, Real}"><code>EquivariantTensors.agnesi_params</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>agnesi_params(pcut, pin, rin, req, rcut)</p><p>Precompute the parameters for the generalized Agnesi transform, to be used with  <code>eval_agnesi</code>. See docs for ??? for details. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/transforms/agnesi.jl#L3-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.agnesi_transform-Tuple{Any, Any, Any, Any, Integer, Integer}"><a class="docstring-binding" href="#EquivariantTensors.agnesi_transform-Tuple{Any, Any, Any, Any, Integer, Integer}"><code>EquivariantTensors.agnesi_transform</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>agnesi_transform(...)</p><p>Construct a generalized Agnesi transform, a layer that implements the operation </p><p class="math-container">\[   y(x) = b_0 + \frac{b_1}{1 + a s^q / (1 + s^(q-p))}\]</p><p>where </p><p class="math-container">\[   s = \frac{r - r_{\rm in}}{r_{\rm eq} - r_{\rm in}}, \]</p><p>with default <code>b_0, b_1</code> such that <span>$r \in [r_{\rm in}, r_{\rm cut}]$</span> is mapped  to <code>[-1, 1]</code> and <code>a</code> such that <span>$|dy/dr|$</span> is maximised at <span>$r = r_{\rm eq}$</span>. </p><p>The transform is constructed to satisfy (assum <span>$r_{\rm in} = 0$</span>)</p><p class="math-container">\[   y \sim \frac{1}{1 + a (r/r_{\rm eq})^q} \quad \text{as} \quad r \to 0 
   \quad \text{and} 
   \quad 
   y \sim (r/r_{\rm eq})^{-p}  \quad \text{as} r \to \infty.\]</p><p>The values for <span>$p, q, r_{\rm in}, r_{\rm eq}, r_{\rm cut}$</span> need to be     specified. Typical defaults for <span>$p,q$</span> are <code>p = 2, q = 4</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/transforms/agnesi.jl#L66-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.cat2idx-Tuple{Any, Any}"><a class="docstring-binding" href="#EquivariantTensors.cat2idx-Tuple{Any, Any}"><code>EquivariantTensors.cat2idx</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>cat2idx(categories, a)</p><p>maps a -&gt; i such that categories[i] == a. Basically  the same as <code>findfirst</code>, similar performance but seems to  avoid an allocation. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/utils/selector.jl#L11-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.catcat2idx-NTuple{4, Any}"><a class="docstring-binding" href="#EquivariantTensors.catcat2idx-NTuple{4, Any}"><code>EquivariantTensors.catcat2idx</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>catcat2idx(categories1, categories2, a1, a2)    catcat2idx(categories, a1, a2)</p><p>same as <code>cat2idx</code> but for pairs of categorical variables,  mapping to a linear index.       </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/utils/selector.jl#L32-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.catcat2idx_sym-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#EquivariantTensors.catcat2idx_sym-Tuple{Any, Any, Any}"><code>EquivariantTensors.catcat2idx_sym</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>catcat2idx_sym(categories, a1, a2)</p><p>Same as <code>catcat2idx</code> but for symmetric pairs, i.e.,  <code>(a1, a2)</code> and <code>(a2, a1)</code> map to the same index. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/utils/selector.jl#L67-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.dp_transform-Tuple{Function}"><a class="docstring-binding" href="#EquivariantTensors.dp_transform-Tuple{Function}"><code>EquivariantTensors.dp_transform</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>function nt<em>transform(f::Function)    function nt</em>transform(f::Function, refstate::NamedTuple)</p><p>If a particle x is represented as a <code>PState</code> (DecoratedParticles.jl)  or a <code>NamedTuple</code><code>, e.g.,</code>x = PState(r = SA[...], Z = 13)<code>,  then an</code>nt_transform` generates a type that incorporates  broadcasting and differentiation. For example </p><pre><code class="language-julia hljs">x = (ùê´ = randn(StaticVector{3, Float64}), Z = rand(10:50))
refstate = (; r0 = SA[ ... ])    # list of r0 values for rescaling r 
trans = dp_transform( (x, st) -&gt; 1 / (1 + norm(x.ùê´)/ st.r0[x.Z]))</code></pre><p>We can then evaluate and differenitate </p><pre><code class="language-julia hljs">y, _ = evaluate(trans, x, ps, st)
(y, dy), _ = evaluate_ed(trans, x, ps, st)</code></pre><p>Here, <code>dy</code> is a <code>VState</code> or a named-tuple with the derivative w.r.t. x.ùê´ stored  as <code>dy.ùê´</code>. The derivative w.r.t. Z is not taken because <code>Z</code> is a categorical  variable.</p><p>The transform is assumed to be parameter-free, or with frozen parameters  stored in the <code>refstate</code>. If a transform has no parameters at all then  one can generate it via </p><pre><code class="language-julia hljs">trans = dp_transform( x -&gt; 1 / (1 + norm(x.ùê´)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/transforms/decpart.jl#L13-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.eval_agnesi-Tuple{Real, NamedTuple}"><a class="docstring-binding" href="#EquivariantTensors.eval_agnesi-Tuple{Real, NamedTuple}"><code>EquivariantTensors.eval_agnesi</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>eval_agnesi(r::Real, params)</p><p>Evaluate the generalized Agnesi transform at distance r, with parameters  provided produced by <code>agnesi_params</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/transforms/agnesi.jl#L47-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.invmap"><a class="docstring-binding" href="#EquivariantTensors.invmap"><code>EquivariantTensors.invmap</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">  invmap(a::AbstractVector)</code></pre><p>Returns a structure that makes looking up the index of an element in a vector  convenient and fast. Assumes that elements of <code>a</code> are unique.</p><pre><code class="language-julia hljs">inva = invmap(a) 
inva[a[i]] == i  # true for all i</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/utils/invmap.jl#L14-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.reshape_embedding-Tuple{Any, EquivariantTensors.ETGraph}"><a class="docstring-binding" href="#EquivariantTensors.reshape_embedding-Tuple{Any, EquivariantTensors.ETGraph}"><code>EquivariantTensors.reshape_embedding</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>reshape_embedding(P, ii, jj, nnodes, maxneigs)</p><p>Takes a Nedges x Nfeat matrix and writes it into a 3-dimensional array of  size (maxneigs, nnodes, Nfeat) where each column corresponds to a node.  The &quot;missing&quot; neighbours are filled with zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/embed/graph.jl#L80-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.rev_reshape_embedding-Tuple{Any, EquivariantTensors.ETGraph}"><a class="docstring-binding" href="#EquivariantTensors.rev_reshape_embedding-Tuple{Any, EquivariantTensors.ETGraph}"><code>EquivariantTensors.rev_reshape_embedding</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>rev<em>reshape</em>embedding(P3, ii, jj, nnodes, maxneigs) -&gt; P</p><p>Reverse operation for <code>reshape_embedding</code>. P3 is of shape  (maxneigs, nnodes, nfeatures), and this gets written into P which is  of shape (nedges, nfeatures) and then returned. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/embed/graph.jl#L112-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.setproduct-Tuple{Any}"><a class="docstring-binding" href="#EquivariantTensors.setproduct-Tuple{Any}"><code>EquivariantTensors.setproduct</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>setproduct(A)</p><p>Assumes the <code>A</code> is a length-N collection of collections. It returns a  <code>P = Matrix{T}</code> where each <code>P[i, :]</code> is a vector of length <code>N</code> with <code>P[i, j] ‚àà A[j]</code>. The number of columns of <code>P</code> is the number of such  products, i.e. <code>prod(length.(A))</code>.</p><p>In constrast with <code>Iterators.product</code> this implementation  is type-stable for a priori unknown <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/utils/setproduct.jl#L2-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.sparse_equivariant_tensor-Tuple{}"><a class="docstring-binding" href="#EquivariantTensors.sparse_equivariant_tensor-Tuple{}"><code>EquivariantTensors.sparse_equivariant_tensor</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>sparse<em>equivariant</em>tensor(L, mb<em>spec, Rnl</em>spec, Ylm_spec, basis)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/ace/sparse_ace_utils.jl#L61-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.sparse_product-Tuple{}"><a class="docstring-binding" href="#EquivariantTensors.sparse_product-Tuple{}"><code>EquivariantTensors.sparse_product</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p><code>sparse_product(...)</code> : utility function to generate high-dimensional sparse grids which are downsets. All arguments are keyword arguments (with defaults):</p><ul><li><code>NU</code> : maximum correlation order</li><li><code>minvv = 0</code> : <code>minvv[i] gives the minimum value for</code>vv[i]`</li><li><code>maxvv = Inf</code> : <code>maxvv[i] gives the minimum value for</code>vv[i]`</li><li><code>tup2bb = vv -&gt; vv</code> :</li><li><code>admissible = _ -&gt; false</code> : determines whether a tuple belongs to the downset</li><li><code>filter = _ -&gt; true</code> : a callable object that returns true of tuple is to be kept and</li></ul><p>false otherwise (whether or not it is part of the downset!) This is used, e.g. to enfore conditions such as ‚àë l‚Çê = even or |‚àë m‚Çê| ‚â¶ M</p><ul><li><code>ordered = false</code> : whether only ordered tuples are produced; ordered tuples</li></ul><p>correspond to  permutation-invariant basis functions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/utils/sparseprod.jl#L4-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.symidx-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#EquivariantTensors.symidx-Tuple{Any, Any, Any}"><code>EquivariantTensors.symidx</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>symidx(j1, j2, n)   </p><p>Computes the index in a flattened symmetric matrix of size n x n, given the row/column indices j1, j2 (1-based). E.g. if n == 3 then  the mapping is as follows:</p><pre><code class="language-julia hljs">   [ 1 2 3
     2 4 5
     3 5 6 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/utils/selector.jl#L50-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.symmetrisation_matrix-Tuple{Integer, Any}"><a class="docstring-binding" href="#EquivariantTensors.symmetrisation_matrix-Tuple{Integer, Any}"><code>EquivariantTensors.symmetrisation_matrix</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>symmetrisation<em>matrix(L, mb</em>spec; prune, kwargs...) -&gt; ùî∏2ùîπ, ùî∏_spec</p><p>Generates the symmetrization operator for a sparse ACE basis. The basis is </p><p><strong>specified via the input <code>mb_spec</code>, which is a list of basis function</strong></p><p>specifications of the form </p><pre><code class="language-julia hljs">mb_spec = [ [(n=0, l=0), (n=1, l=0)], [(n=1, l=1), (n=2, l=1)], ... ] </code></pre><p>i.e. a <code>Vector{Vector{NL}}</code>. where <code>NL = @NamedTuple{n::Int, l::Int}</code>.</p><p>The parameter <code>L</code> determines the order of the ouput, e.g. L=0 for an invariant  scalar, L = 1 for a vector, and so forth. </p><p>The output is given in terms of a sparse matrix <code>ùî∏2ùîπ</code> in CCS format and a  specification of the <code>ùî∏</code> basis as a <code>Vector{Vector{NLM}}</code> where  <code>NLM = @NamedTuple{n::Int, l::Int, m::Int}</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/utils/symmop.jl#L4-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.O3.TYVec2CartMat"><a class="docstring-binding" href="#EquivariantTensors.O3.TYVec2CartMat"><code>EquivariantTensors.O3.TYVec2CartMat</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>struct TYVec2CartMat </p><p>transformation from a real Y vector to a cartesian matrix; accepts as input  either an <code>SVector{3}</code><code>(i.e. the Y_1^m) or a</code>SYYVector<code>(containing both  the Y_0^0 and Y_1^m); the output is a</code>SMatrix{3,3}`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/O3/O3_transformations.jl#L61-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.O3.TYVec2CartVec"><a class="docstring-binding" href="#EquivariantTensors.O3.TYVec2CartVec"><code>EquivariantTensors.O3.TYVec2CartVec</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>struct TYVec2CartVec </p><p>transformation from a real Y vector to a cartesian vector; accepts as input  either an <code>SVector{3}</code><code>(i.e. the Y_1^m) or a</code>SYYVector<code>(containing both  the Y_0^0 and Y_1^m); the output is a</code>SVector{3}`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/O3/O3_transformations.jl#L29-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.O3.TYVec2YMat"><a class="docstring-binding" href="#EquivariantTensors.O3.TYVec2YMat"><code>EquivariantTensors.O3.TYVec2YMat</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>struct TYVec2YMat</p><p>transformation from a real Y vector to a spherical matrix       </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/O3/O3_transformations.jl#L5-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.O3.D_from_angles-Tuple{Integer, AbstractVector{&lt;:Real}, typeof(real)}"><a class="docstring-binding" href="#EquivariantTensors.O3.D_from_angles-Tuple{Integer, AbstractVector{&lt;:Real}, typeof(real)}"><code>EquivariantTensors.O3.D_from_angles</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>D<em>from</em>angles(l, Œ∏, basis)</p><p>Here, <code>l::Integer</code> and <code>Œ∏</code> a 3-element vector or tuple, <code>basis</code> must be either  <code>real</code> or <code>complex</code>. Output is a Wigner-D matrix such that <code>y ‚àò Q = D * y</code>  with <code>y</code> real/complex spherical harmonics. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/O3/O3_utils.jl#L176-L182">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.O3.QD_from_angles-Tuple{Integer, AbstractVector{&lt;:Real}, Any}"><a class="docstring-binding" href="#EquivariantTensors.O3.QD_from_angles-Tuple{Integer, AbstractVector{&lt;:Real}, Any}"><code>EquivariantTensors.O3.QD_from_angles</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>produces a rotation Q and Wigner-D matrix D such that <code>y ‚àò Q = D * y</code> with <code>y</code> real spherical harmonics. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/O3/O3_utils.jl#L190-L193">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EquivariantTensors.O3.coupling_coeffs"><a class="docstring-binding" href="#EquivariantTensors.O3.coupling_coeffs"><code>EquivariantTensors.O3.coupling_coeffs</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">O3.coupling_coeffs(L, ll, nn; PI, basis)
O3.coupling_coeffs(L, ll; PI, basis)</code></pre><p>Compute coupling coefficients for the spherical harmonics basis, where </p><ul><li><code>L</code> must be an <code>Integer</code>;</li><li><code>ll, nn</code> must be vectors or tuples of <code>Integer</code> of the same length.</li><li><code>PI</code>: whether or not the coupled basis is permutation-invariant (or the </li></ul><p>corresponding tensor symmetric); default is <code>true</code> when <code>nn</code> is provided  and <code>false</code> when <code>nn</code> is not provided.</p><ul><li><code>basis</code>: which basis is being coupled, default is <code>complex</code>, alternative</li></ul><p>choice is <code>real</code>, which is compatible with the <code>SpheriCart.jl</code> convention.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/EquivariantTensors.jl/blob/a5ab100dce294a38c167ddc19dd566fe899f0323/src/O3/O3.jl#L281-L293">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/">¬´ Public API</a><a class="docs-footer-nextpage" href="../benchmarking/">Benchmarking ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 23 December 2025 06:03">Tuesday 23 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
