var documenterSearchIndex = {"docs":
[{"location":"api/#Public-API","page":"Public API","title":"Public API","text":"EquivariantTensors provides several building blocks for (neural and) tensor networks that preserve various symmetries. These can be combined into various tensor formats from which equivariant parameterized models can be built. ","category":"section"},{"location":"api/#Building-Blocks","page":"Public API","title":"Building Blocks","text":"Fused tensor product and pooling PooledSparseProduct\nSparse symmetric product SparseSymmProd\n\nEvaluating a layer can be done both in-place or allocating, e.g., via \n\nabasis::SparseSymmProd\nevaluate!(AA, abasis, A)\nAA = evaluate(abasis, A)\n\nWe refer to the individual documentation for the details of the arguments to each layer. \n\nAll tensor layers have custom pullbacks implemented that can be accessed via non-allocating or allocating calls, e.g., \n\npullback!(‚àÇAA, ‚àÇA, abasis, A)\n‚àÇAA = pullback(‚àÇA, abasis, A)\n\nPushforwards and reverse-over-reverse are implemented using ForwardDiff. This is quasi-optimal even for reverse-over-reverse due to the fact that it can be interpreted as a directional derivative on evaluate and pullback (after swapping derivatives). As a matter of fact, we generally recommend to not use these directly. ChainRules integration would give an easier use-pattern. For optimal performance the same technique should be applied to an entire model architecture rather than to each individual layer. This would avoid several unnecessary intermediate allocations.\n\nThe syntax for pushforwards is straightforward:\n\npushforward!(P, ‚àÇP, layer, X, ‚àÇX)\nP, ‚àÇP = pushforward(layer, X, ‚àÇX)\n\nFor second-order pullbacks the syntax is \n\npullback2!(‚àá_‚àÇP, ‚àá_X, ‚àÇ‚àÇX, ‚àÇP, layer, X)\n‚àá_‚àÇP, ‚àá_X = pullback2(‚àÇ‚àÇX, ‚àÇP, layer, X)","category":"section"},{"location":"api/#Bumper-and-WithAlloc-usage","page":"Public API","title":"Bumper and WithAlloc usage","text":"Using the WithAlloc.jl interface the api can be used conveniently as follows (always from within a @no_escape block)\n\nA = @withalloc evaluate!(abasis, BB)\n‚àÇX = @withalloc pullback!(‚àÇP, layer, X)\nP, ‚àÇP = @withalloc pushforward!(layer, X, ‚àÇX)","category":"section"},{"location":"api/#Lie-Group-Symmetrization-/-Coupling-Operators","page":"Public API","title":"Lie Group Symmetrization / Coupling Operators","text":"Construct coupling coefficients: O3.coupling_coeffs\n\n(TODO: detailed description)","category":"section"},{"location":"api/#Pre-built-Equivariant-Tensors","page":"Public API","title":"Pre-built Equivariant Tensors","text":"","category":"section"},{"location":"benchmarking/#Benchmarking-Instructions","page":"Benchmarking","title":"Benchmarking Instructions","text":"For general reference see BenchmarkTools.jl manual.\n\nA simple way to run benchmarks is to call\n\nusing BenchmarkTools\nusing PkgBenchmark\nusing EquivariantTensors\n\nbench = benchmarkpkg(EquivariantTensors)\nresults = bench.benchmarkgroup\n\n# You can search with macro \"@tagged\"\nresults[@tagged \"derivative\" && \"Chebyshev\"]\n\nYou can create BenchmarkConfig to control benchmark\n\nt2 = BenchmarkConfig(env = Dict(\"JULIA_NUM_THREADS\" => 2))\nbench_t2 = benchmarkpkg(EquivariantTensors, t2)\n\nBenchmarks can be saved to a file with\n\nexport_markdown(\"results.md\", bench)\n\nComparing current branch to another branch\n\n# current branch to \"origin/main\"\nj = judge(EquivariantTensors, \"origin/main\")\n\nBenchmark scaling to different number of threads\n\nt4 = BenchmarkConfig(env = Dict(\"JULIA_NUM_THREADS\" => 4))\nt8 = BenchmarkConfig(env = Dict(\"JULIA_NUM_THREADS\" => 8))\n\n# Compare how much changing from 4-threads to 8 improves the performance\nj = judge(EquivariantTensors, t8, t4)\n\nshow(j.benchmarkgroup)","category":"section"},{"location":"benchmarking/#CI-Benchmarks","page":"Benchmarking","title":"CI Benchmarks","text":"Benchmarks can be run automatically on PR's by adding label \"run benchmark\" to the PR.","category":"section"},{"location":"benchmarking/#Adding-more-benchmarks","page":"Benchmarking","title":"Adding more benchmarks","text":"Take a look at benchmark/benchmarks.jl for an example. If your benchmark depends on additional packages you need to add the package to benchmark/Project.toml.","category":"section"},{"location":"#EquivariantTensors","page":"Home","title":"EquivariantTensors","text":"These pages contain the documentation for EquivariantTensors. This package provides tools to construct equivariant tensor layers to be used in equivariant models, as well as computational kernels to evaluate those layers.\n\nThe package is a work in progress. The plan is that it becomes the backend for several ACEsuit packages such as ACEpotentials.jl and ACEhamiltonians.jl.\n\nThe documentation is very rudimentary for now. We suggest to look at the tests, inline docs and the examples.","category":"section"},{"location":"docstrings/#Docstrings","page":"Docstrings","title":"Docstrings","text":"This page lists all docstrings in EquivariantTensors.jl including for functions that are not part of the public API. Please check with the Public API for which functionality we aim to guarantee semver-stability.\n\n","category":"section"},{"location":"docstrings/#EquivariantTensors.Envelope","page":"Docstrings","title":"EquivariantTensors.Envelope","text":"To be used as part of TransformedBasis as follows: \n\ny = transform(x) \nP = basis(y) * envelope(x, y)\n\nWarning: P may be modified in-place!\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#EquivariantTensors.NTtransform","page":"Docstrings","title":"EquivariantTensors.NTtransform","text":"If a particle x is represented as a NamedTuple, e.g., x = (r = SA[...], Z = 13) then an NTtransform can be used to embed this named tuple into ‚Ñù in a differentiable  way, e.g., \n\nx = (ùê´ = randn(StaticVector{3, Float64}), Z = rand(10:50))\nr0 = Float64[ ... ]  # list of r0 values for rescaling r \ntrans = NTtransform(x -> 1 / (1 + norm(x.ùê´)/r0[x.Z]))\n\nWe can then evaluate and differenitate \n\ny = evaluate(trans, x, ps, st)\ny, dy = evaluate_ed(trans, x, ps, st)\n\nHere, dy is again a named-tuple with the derivative w.r.t. x.ùê´ stored as  dy.ùê´. The derivative w.r.t. Z is not taken because Z is a categorical variable.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#EquivariantTensors.NTtransformST","page":"Docstrings","title":"EquivariantTensors.NTtransformST","text":"Experimental extension of NTtransform that allows states. (to be extended to also allow paramters)\n\nMaybe a better approach would be to have just wrap a callable, and let that  callable take care of the parameters. otoh, what we are doing here is  more convenient to build on-the-fly ...\n\nNOT PART OF THE OFFICIAL API YET! CAN CHANGE WITHOUT NOTICE!\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#EquivariantTensors.ParallelEmbed","page":"Docstrings","title":"EquivariantTensors.ParallelEmbed","text":"struct ParallelEmbed : basically a variation on Lux.Parallel,  but makes some assumptions on what the individual layers to  be evaluated in parallel do to enable some simple optimizations. \n\nThe assumption is that each layer is a \"basis\", i.e. a mapping x -> B(x),  where x is low-dimensional and B(x) is moderate-dimensional. This means that  the optimal differentiation is in forward-mode. This is exploited by  implementing the functions evaluate and evaluate_ed. For implementing  models that use ParallelEmbed a forward-pass that also differentiates  (e.g. energy and forces) is implemented with evaluate_ed. \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#EquivariantTensors.PooledSparseProduct","page":"Docstrings","title":"EquivariantTensors.PooledSparseProduct","text":"struct PooledSparseProduct :  This implements a fused (tensor) product and pooling operation. Suppose  we are given N embeddings phi^(i)_k_i then the pooled sparse product  generates feature vectors of the form \n\nA_k_1 dots k_N = sum_j prod_t = 1^N phi^(t)_k_t(x_j)\n\nwhere x_j are an list of inputs (multi-set). \n\nThe canonical example is \n\nA_nlm = sum_j R_nl(r_j mu_j) Y_l^m( hatbm r_j )\n\nwhere R_nl is a radial embedding, possibly depending on a categorical  variable mu_j and Y_l^m are spherical harmonics. \n\nConstructor\n\nPooledSparseProduct(spec)\n\nwhere spec is a list of (k_1 dots k_N) tuples or vectors, or  AbstractMatrix where each column specifies such a tuple. \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#EquivariantTensors.SelectLinL","page":"Docstrings","title":"EquivariantTensors.SelectLinL","text":"struct SelectLinL <: AbstractLuxLayer\n\nA Lux layer which acts as a simple linear layer, but using a categorical  variable to select a weight matrix:\n\n   P -> W[x] * P \n\nThis layer is experimental and likely very inefficient. \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#EquivariantTensors.SparseMatCSX","page":"Docstrings","title":"EquivariantTensors.SparseMatCSX","text":"struct SparseMatCSX\n\nSparse matrix format that is stored in both CSR and CSC, and can be transferred  to GPU devices. Matrix multiplication via KernelAbstractions.jl for GPU support and uses whichever format (CSR, CSC) is most suitable for a given operation. \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#EquivariantTensors.SparseSymmProd","page":"Docstrings","title":"EquivariantTensors.SparseSymmProd","text":"SparseSymmProd : sparse symmetric product with entries stored as tuples.  Input is a vector A; each entry of the output vector AA is of the form \n\n bm A_i_1 dots i_N = prod_t = 1^N A_i_t\n\nConstructor\n\nSparseSymmProd(spec)\n\nwhere spec is a list of tuples or vectors, each of which specifies an AA basis function as described above. For example, \n\nspec = [ (1,), (2,), (1,1), (1,2), (2,2), \n         (1,1,1), (1,1,2), (1,2,2), (2,2,2) ]\nbasis = SparseSymmProd(spec)         \n\ndefines a basis of 9 functions, \n\n A_1 A_2 A_1^2 A_1 A_2 A_2^2 A_1^3 A_1^2 A_2 A_1 A_2^2 A_2^3 \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#EquivariantTensors.TransformedBasis","page":"Docstrings","title":"EquivariantTensors.TransformedBasis","text":"struct TransformedBasis\n\nBasically a three-stage chain, consisting of an input transformation,  and basis evaluation. Constructor: \n\nTransformedBasis(; transin, basis, transout)\n\ndefaults for transin and transout are IDtrans(), i.e. identity  transformations.\n\nThe layer performs the following chain: \n\ny = evaluate(transin, x, ...)\nP = evaluate(basis, y, ...) \nB = evaluate(transout, P, x, ...)\n\nIt is assumed that transout only utilizes the categorical variables stored in \n\nx but not the continuous variables. This means that when differentiating,  one only needs to differentiate B(P(y), x) with respect to y but not  with respect to x.\n\nit is also assumed that basis has no parameters \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#EquivariantTensors._auto_Rnl_spec-Tuple{Any}","page":"Docstrings","title":"EquivariantTensors._auto_Rnl_spec","text":"Takes a list of ùî∏ or ùîπ specifications (many-body) in the form of \n\n   [  [(n=., l=., m=.), (n=., l=., m=.)], ... ]\n\nand converts it into a list of sorted unique (n=., l=.) named pairs,  i.e the specification of the one-body basis. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EquivariantTensors._auto_Ylm_spec-Tuple{Any, Any}","page":"Docstrings","title":"EquivariantTensors._auto_Ylm_spec","text":"autoYlmspec(mbspec) \n\ntakes a list of ùî∏ or ùîπ specifications (many-body) and return the specification  of the Ylm basis functions as a [ (l = ., m = .), ... ] list. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EquivariantTensors._auto_nnllmm_spec-Tuple{Any}","page":"Docstrings","title":"EquivariantTensors._auto_nnllmm_spec","text":"takes an nnll spec and generates a complete list of all possible nnllmm\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EquivariantTensors._make_idx_AA_spec-Tuple{Any, Any}","page":"Docstrings","title":"EquivariantTensors._make_idx_AA_spec","text":"convert readable AA_spec into the internal representation of the AA basis\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EquivariantTensors._make_idx_A_spec-Tuple{Any, Vector{@NamedTuple{n::Int64}}, Any}","page":"Docstrings","title":"EquivariantTensors._make_idx_A_spec","text":"convert readable A_spec into the internal representation of the A basis\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EquivariantTensors.agnesi_params-Tuple{Integer, Integer, Real, Real, Real}","page":"Docstrings","title":"EquivariantTensors.agnesi_params","text":"agnesi_params(pcut, pin, rin, req, rcut)\n\nPrecompute the parameters for the generalized Agnesi transform, to be used with  eval_agnesi. See docs for ??? for details. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EquivariantTensors.agnesi_transform-Tuple{Any, Any, Any, Any, Integer, Integer}","page":"Docstrings","title":"EquivariantTensors.agnesi_transform","text":"agnesi_transform(...)\n\nConstruct a generalized Agnesi transform, a layer that implements the operation \n\n   y(x) = b_0 + fracb_11 + a s^q  (1 + s^(q-p))\n\nwhere \n\n   s = fracr - r_rm inr_rm eq - r_rm in \n\nwith default b_0, b_1 such that r in r_rm in r_rm cut is mapped  to [-1, 1] and a such that dydr is maximised at r = r_rm eq. \n\nThe transform is constructed to satisfy (assum r_rm in = 0)\n\n   y sim frac11 + a (rr_rm eq)^q quad textas quad r to 0 \n   quad textand \n   quad \n   y sim (rr_rm eq)^-p  quad textas r to infty\n\nThe values for p q r_rm in r_rm eq r_rm cut need to be     specified. Typical defaults for pq are p = 2, q = 4. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EquivariantTensors.cat2idx-Tuple{Any, Any}","page":"Docstrings","title":"EquivariantTensors.cat2idx","text":"cat2idx(categories, a)\n\nmaps a -> i such that categories[i] == a. Basically  the same as findfirst, similar performance but seems to  avoid an allocation. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EquivariantTensors.catcat2idx-NTuple{4, Any}","page":"Docstrings","title":"EquivariantTensors.catcat2idx","text":"catcat2idx(categories1, categories2, a1, a2)    catcat2idx(categories, a1, a2)\n\nsame as cat2idx but for pairs of categorical variables,  mapping to a linear index.       \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EquivariantTensors.catcat2idx_sym-Tuple{Any, Any, Any}","page":"Docstrings","title":"EquivariantTensors.catcat2idx_sym","text":"catcat2idx_sym(categories, a1, a2)\n\nSame as catcat2idx but for symmetric pairs, i.e.,  (a1, a2) and (a2, a1) map to the same index. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EquivariantTensors.eval_agnesi-Tuple{Real, NamedTuple}","page":"Docstrings","title":"EquivariantTensors.eval_agnesi","text":"eval_agnesi(r::Real, params)\n\nEvaluate the generalized Agnesi transform at distance r, with parameters  provided produced by agnesi_params. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EquivariantTensors.invmap","page":"Docstrings","title":"EquivariantTensors.invmap","text":"  invmap(a::AbstractVector)\n\nReturns a structure that makes looking up the index of an element in a vector  convenient and fast. Assumes that elements of a are unique.\n\ninva = invmap(a) \ninva[a[i]] == i  # true for all i\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#EquivariantTensors.reshape_embedding-Tuple{Any, EquivariantTensors.ETGraph}","page":"Docstrings","title":"EquivariantTensors.reshape_embedding","text":"reshape_embedding(P, ii, jj, nnodes, maxneigs)\n\nTakes a Nedges x Nfeat matrix and writes it into a 3-dimensional array of  size (maxneigs, nnodes, Nfeat) where each column corresponds to a node.  The \"missing\" neighbours are filled with zeros.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EquivariantTensors.rev_reshape_embedding-Tuple{Any, EquivariantTensors.ETGraph}","page":"Docstrings","title":"EquivariantTensors.rev_reshape_embedding","text":"revreshapeembedding(P3, ii, jj, nnodes, maxneigs) -> P\n\nReverse operation for reshape_embedding. P3 is of shape  (maxneigs, nnodes, nfeatures), and this gets written into P which is  of shape (nedges, nfeatures) and then returned. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EquivariantTensors.setproduct-Tuple{Any}","page":"Docstrings","title":"EquivariantTensors.setproduct","text":"setproduct(A)\n\nAssumes the A is a length-N collection of collections. It returns a  P = Matrix{T} where each P[i, :] is a vector of length N with P[i, j] ‚àà A[j]. The number of columns of P is the number of such  products, i.e. prod(length.(A)).\n\nIn constrast with Iterators.product this implementation  is type-stable for a priori unknown N.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EquivariantTensors.sparse_equivariant_tensor-Tuple{}","page":"Docstrings","title":"EquivariantTensors.sparse_equivariant_tensor","text":"sparseequivarianttensor(L, mbspec, Rnlspec, Ylm_spec, basis)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EquivariantTensors.sparse_product-Tuple{}","page":"Docstrings","title":"EquivariantTensors.sparse_product","text":"sparse_product(...) : utility function to generate high-dimensional sparse grids which are downsets. All arguments are keyword arguments (with defaults):\n\nNU : maximum correlation order\nminvv = 0 : minvv[i] gives the minimum value forvv[i]`\nmaxvv = Inf : maxvv[i] gives the minimum value forvv[i]`\ntup2bb = vv -> vv :\nadmissible = _ -> false : determines whether a tuple belongs to the downset\nfilter = _ -> true : a callable object that returns true of tuple is to be kept and\n\nfalse otherwise (whether or not it is part of the downset!) This is used, e.g. to enfore conditions such as ‚àë l‚Çê = even or |‚àë m‚Çê| ‚â¶ M\n\nordered = false : whether only ordered tuples are produced; ordered tuples\n\ncorrespond to  permutation-invariant basis functions\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EquivariantTensors.symidx-Tuple{Any, Any, Any}","page":"Docstrings","title":"EquivariantTensors.symidx","text":"symidx(j1, j2, n)   \n\nComputes the index in a flattened symmetric matrix of size n x n, given the row/column indices j1, j2 (1-based). E.g. if n == 3 then  the mapping is as follows:\n\n   [ 1 2 3\n     2 4 5\n     3 5 6 ]\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EquivariantTensors.symmetrisation_matrix-Tuple{Integer, Any}","page":"Docstrings","title":"EquivariantTensors.symmetrisation_matrix","text":"symmetrisationmatrix(L, mbspec; prune, kwargs...) -> ùî∏2ùîπ, ùî∏_spec\n\nGenerates the symmetrization operator for a sparse ACE basis. The basis is \n\nspecified via the input mb_spec, which is a list of basis function\n\nspecifications of the form \n\nmb_spec = [ [(n=0, l=0), (n=1, l=0)], [(n=1, l=1), (n=2, l=1)], ... ] \n\ni.e. a Vector{Vector{NL}}. where NL = @NamedTuple{n::Int, l::Int}.\n\nThe parameter L determines the order of the ouput, e.g. L=0 for an invariant  scalar, L = 1 for a vector, and so forth. \n\nThe output is given in terms of a sparse matrix ùî∏2ùîπ in CCS format and a  specification of the ùî∏ basis as a Vector{Vector{NLM}} where  NLM = @NamedTuple{n::Int, l::Int, m::Int}. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EquivariantTensors.O3.TYVec2CartMat","page":"Docstrings","title":"EquivariantTensors.O3.TYVec2CartMat","text":"struct TYVec2CartMat \n\ntransformation from a real Y vector to a cartesian matrix; accepts as input  either an SVector{3}(i.e. the Y_1^m) or aSYYVector(containing both  the Y_0^0 and Y_1^m); the output is aSMatrix{3,3}`.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#EquivariantTensors.O3.TYVec2CartVec","page":"Docstrings","title":"EquivariantTensors.O3.TYVec2CartVec","text":"struct TYVec2CartVec \n\ntransformation from a real Y vector to a cartesian vector; accepts as input  either an SVector{3}(i.e. the Y_1^m) or aSYYVector(containing both  the Y_0^0 and Y_1^m); the output is aSVector{3}`.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#EquivariantTensors.O3.TYVec2YMat","page":"Docstrings","title":"EquivariantTensors.O3.TYVec2YMat","text":"struct TYVec2YMat\n\ntransformation from a real Y vector to a spherical matrix       \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#EquivariantTensors.O3.D_from_angles-Tuple{Integer, AbstractVector{<:Real}, typeof(real)}","page":"Docstrings","title":"EquivariantTensors.O3.D_from_angles","text":"Dfromangles(l, Œ∏, basis)\n\nHere, l::Integer and Œ∏ a 3-element vector or tuple, basis must be either  real or complex. Output is a Wigner-D matrix such that y ‚àò Q = D * y  with y real/complex spherical harmonics. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EquivariantTensors.O3.QD_from_angles-Tuple{Integer, AbstractVector{<:Real}, Any}","page":"Docstrings","title":"EquivariantTensors.O3.QD_from_angles","text":"produces a rotation Q and Wigner-D matrix D such that y ‚àò Q = D * y with y real spherical harmonics. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EquivariantTensors.O3.coupling_coeffs","page":"Docstrings","title":"EquivariantTensors.O3.coupling_coeffs","text":"O3.coupling_coeffs(L, ll, nn; PI, basis)\nO3.coupling_coeffs(L, ll; PI, basis)\n\nCompute coupling coefficients for the spherical harmonics basis, where \n\nL must be an Integer;\nll, nn must be vectors or tuples of Integer of the same length.\nPI: whether or not the coupled basis is permutation-invariant (or the \n\ncorresponding tensor symmetric); default is true when nn is provided  and false when nn is not provided.\n\nbasis: which basis is being coupled, default is complex, alternative\n\nchoice is real, which is compatible with the SpheriCart.jl convention.  \n\n\n\n\n\n","category":"function"}]
}
