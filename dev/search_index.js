var documenterSearchIndex = {"docs":
[{"location":"api/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"benchmarking/#Benchmarking-Instructions","page":"Benchmarking Instructions","title":"Benchmarking Instructions","text":"","category":"section"},{"location":"benchmarking/","page":"Benchmarking Instructions","title":"Benchmarking Instructions","text":"For general reference see BenchmarkTools.jl manual.","category":"page"},{"location":"benchmarking/","page":"Benchmarking Instructions","title":"Benchmarking Instructions","text":"A simple way to run benchmarks is to call","category":"page"},{"location":"benchmarking/","page":"Benchmarking Instructions","title":"Benchmarking Instructions","text":"using BenchmarkTools\nusing PkgBenchmark\nusing EquivariantTensors\n\nbench = benchmarkpkg(EquivariantTensors)\nresults = bench.benchmarkgroup\n\n# You can search with macro \"@tagged\"\nresults[@tagged \"derivative\" && \"Chebyshev\"]","category":"page"},{"location":"benchmarking/","page":"Benchmarking Instructions","title":"Benchmarking Instructions","text":"You can create BenchmarkConfig to control benchmark","category":"page"},{"location":"benchmarking/","page":"Benchmarking Instructions","title":"Benchmarking Instructions","text":"t2 = BenchmarkConfig(env = Dict(\"JULIA_NUM_THREADS\" => 2))\nbench_t2 = benchmarkpkg(EquivariantTensors, t2)","category":"page"},{"location":"benchmarking/","page":"Benchmarking Instructions","title":"Benchmarking Instructions","text":"Benchmarks can be saved to a file with","category":"page"},{"location":"benchmarking/","page":"Benchmarking Instructions","title":"Benchmarking Instructions","text":"export_markdown(\"results.md\", bench)","category":"page"},{"location":"benchmarking/","page":"Benchmarking Instructions","title":"Benchmarking Instructions","text":"Comparing current branch to another branch","category":"page"},{"location":"benchmarking/","page":"Benchmarking Instructions","title":"Benchmarking Instructions","text":"# current branch to \"origin/main\"\nj = judge(EquivariantTensors, \"origin/main\")","category":"page"},{"location":"benchmarking/","page":"Benchmarking Instructions","title":"Benchmarking Instructions","text":"Benchmark scaling to different number of threads","category":"page"},{"location":"benchmarking/","page":"Benchmarking Instructions","title":"Benchmarking Instructions","text":"t4 = BenchmarkConfig(env = Dict(\"JULIA_NUM_THREADS\" => 4))\nt8 = BenchmarkConfig(env = Dict(\"JULIA_NUM_THREADS\" => 8))\n\n# Compare how much changing from 4-threads to 8 improves the performance\nj = judge(EquivariantTensors, t8, t4)\n\nshow(j.benchmarkgroup)","category":"page"},{"location":"benchmarking/#CI-Benchmarks","page":"Benchmarking Instructions","title":"CI Benchmarks","text":"","category":"section"},{"location":"benchmarking/","page":"Benchmarking Instructions","title":"Benchmarking Instructions","text":"Benchmarks can be run automatically on PR's by adding label \"run benchmark\" to the PR.","category":"page"},{"location":"benchmarking/#Adding-more-benchmarks","page":"Benchmarking Instructions","title":"Adding more benchmarks","text":"","category":"section"},{"location":"benchmarking/","page":"Benchmarking Instructions","title":"Benchmarking Instructions","text":"Take a look at benchmark/benchmarks.jl for an example. If your benchmark depends on additional packages you need to add the package to benchmark/Project.toml.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = EquivariantTensors","category":"page"},{"location":"#EquivariantTensors","page":"Home","title":"EquivariantTensors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These pages will contain the documentation for EquivariantTensors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [EquivariantTensors, EquivariantTensors.O3]","category":"page"},{"location":"#EquivariantTensors.PooledSparseProduct","page":"Home","title":"EquivariantTensors.PooledSparseProduct","text":"struct PooledSparseProduct :  This implements a fused (tensor) product and pooling operation. Suppose  we are given N embeddings phi^(i)_k_i then the pooled sparse product  generates feature vectors of the form \n\nA_k_1 dots k_N = sum_j prod_t = 1^N phi^(t)_k_t(x_j)\n\nwhere x_j are an list of inputs (multi-set). \n\nConstructor\n\nPooledSparseProduct(spec)\n\nwhere spec is a list of (k_1 dots k_N) tuples or vectors, or  AbstractMatrix where each column specifies such a tuple. \n\n\n\n\n\n","category":"type"},{"location":"#EquivariantTensors.SparseSymmProd","page":"Home","title":"EquivariantTensors.SparseSymmProd","text":"SparseSymmProd : sparse symmetric product with entries stored as tuples.  Input is a vector A; each entry of the output vector AA is of the form \n\n bm A_i_1 dots i_N = prod_t = 1^N A_i_t\n\nConstructor\n\nSparseSymmProd(spec)\n\nwhere spec is a list of tuples or vectors, each of which specifies an AA basis function as described above. For example, \n\nspec = [ (1,), (2,), (1,1), (1,2), (2,2), \n         (1,1,1), (1,1,2), (1,2,2), (2,2,2) ]\nbasis = SparseSymmProd(spec)         \n\ndefines a basis of 9 functions, \n\n A_1 A_2 A_1^2 A_1 A_2 A_2^2 A_1^3 A_1^2 A_2 A_1 A_2^2 A_2^3 \n\n\n\n\n\n","category":"type"},{"location":"#EquivariantTensors._gensparse-Union{Tuple{NU}, Tuple{Val{NU}, Vararg{Any, 7}}} where NU","page":"Home","title":"EquivariantTensors._gensparse","text":"_gensparse : function barrier for gensparse\n\n\n\n\n\n","category":"method"},{"location":"#EquivariantTensors.gensparse-Tuple{}","page":"Home","title":"EquivariantTensors.gensparse","text":"gensparse(...) : utility function to generate high-dimensional sparse grids which are downsets. All arguments are keyword arguments (with defaults):\n\nNU : maximum correlation order\nminvv = 0 : minvv[i] gives the minimum value forvv[i]`\nmaxvv = Inf : maxvv[i] gives the minimum value forvv[i]`\ntup2b = vv -> vv :\nadmissible = _ -> false : determines whether a tuple belongs to the downset\nfilter = _ -> true : a callable object that returns true of tuple is to be kept and\n\nfalse otherwise (whether or not it is part of the downset!) This is used, e.g. to enfore conditions such as ∑ lₐ = even or |∑ mₐ| ≦ M\n\nINT = Int : integer type to be used\nordered = false : whether only ordered tuples are produced; ordered tuples\n\ncorrespond to  permutation-invariant basis functions\n\n\n\n\n\n","category":"method"},{"location":"#EquivariantTensors.O3.coupling_coeffs","page":"Home","title":"EquivariantTensors.O3.coupling_coeffs","text":"O3.coupling_coeffs(L, ll, nn; PI, basis)\nO3.coupling_coeffs(L, ll; PI, basis)\n\nCompute coupling coefficients for the spherical harmonics basis, where \n\nL must be an Integer;\nll, nn must be vectors or tuples of Integer of the same length.\nPI: whether or not the coupled basis is permutation-invariant (or the \n\ncorresponding tensor symmetric); default is true when nn is provided  and false when nn is not provided.\n\nbasis: which basis is being coupled, default is complex, alternative\n\nchoice is real, which is compatible with the SpheriCart.jl convention.  \n\n\n\n\n\n","category":"function"}]
}
